等价模型
lisp在计算一个表达式遵循由小到大，由简到繁。先计算每个子表达式，用实参代替形参，找到过程定义，对子表达式求值,以下列代码为例，
```
define (sum-of-squares x y)  
			(+ (square x) (square y)))

(define (f x) (sum-of-squares (+ x 1) (+ x 2)))
(f 5) 
(sum-of-squares (+ 5 1) (* 5 2)) ; 注意这两行，首先算出来形参
(+ (square 6) (square 10)) 
(+ (* 6 6) (* 10 10))
(+ 36 100)
136
```
上述每次计算都会把子表达式得到结果，一步一步往下传，也叫应用序计算。

```
 (f 5) 
 (sum-of-squares (+ 5 1) (* 5 2))
 (+ (square (+ 5 1)) (square (* 5 2)) ); 注意这两行这里没往下计算形参
 (+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))
 (+ (* 6 6) (* 10 10)) ; 反倒是都摊开了才开始进行规约
 (+ 36 100)
 136
```


参数为过程
是为了更好的抽象，把类似的代码抽象成一个过程，然后传入到另个函数。

返回为函数